package com.knits.jpa.orm.entities01.one.to.one.test;

import java.io.Serializable;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.MapsId;
import javax.persistence.OneToOne;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Table;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import com.hibernate.bootstrap.util.AbstractJPAProgrammaticBootstrapTest;
import com.knits.jpa.orm.entities.common.MockEntities;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TestOneToOne01_SharedPrimaryKey extends AbstractJPAProgrammaticBootstrapTest {

	

	//@Test
	public void testTableCreations() {
		doInJPATransaction(entityManager -> {
			log.info("Check tables created in DB");
		});
	}

	
	//@Test
	public void testInsert() {
		
		doInJPATransaction(entityManager -> {
						
			// entities not persisted, id should be null for both
			Assert.assertNull(user.getId());
			Assert.assertNull(address.getId());
									
			entityManager.persist(user); // is possible to persist user because of autogenerated id
			Assert.assertNotNull(user.getId()); // after persist id is generated..
			
			
			user.setAddress(address); // without this next persist will fail because
			entityManager.persist(address); // ...address needs the id of parent user
			
			
			// now both entities have same id. They will be saved on DB when transaction commits
			Assert.assertNotNull(address.getId());
			Assert.assertEquals(user.getId().longValue(), address.getId().longValue());	
			
		});
		
	}
	
	
	//@Test
	public void testBidirectional() {

		doInJPATransaction(entityManager -> {

		
			// @Review (1): Need to update BOTH side of relationship
			/*
			  user.setAddress(address); 
			  address.setUser(user);
			
			 */

			// @Review (2):Instead of replication above code (@Review(1)) everywhere in services 
			// would be better to implement it in model classes
			
			/*
			  //only one set is updating both objects 
			  user.setAddress(address);
			  Assert.assertNotNull(address.getUser());	
			  
			  // disconnect the entities passing null to setter on parent entity
			  user.setAddress(null);
			  Assert.assertNull(address.getUser());
			 			 
			  // Careful!! updates on child entity are not updating both sides!
			  address.setUser(user); 
			  Assert.assertNull(user.getAddress());
			 */

			// @Review (3):
			//if connected JPA engine will understand which entity to save first (see logs)
			//entityManager.persist(address); // this needs id of user to be saved first..
			entityManager.persist(user);
			
		});
	}

	@Test
	public void testCascade() {

		doInJPATransaction(entityManager -> {

			// both transient in beginning (no ids)
			Assert.assertNull(user.getId());
			Assert.assertNull(address.getId());

			
			// @Review (4): without cascade I need to save them both
			/*
			user.setAddress(address);
			entityManager.persist(user); 
			entityManager.persist(address);
			Assert.assertNotNull(user.getId());
			Assert.assertNotNull(address.getId());
			*/
			
			// @Review (5): cascade (persist or all) on parent propagates on children
			/*
			user.setAddress(address);
			entityManager.persist(user); // address will be persisted here automatically			
			Assert.assertNotNull(user.getId());
			Assert.assertNotNull(address.getId());
			*/
			

		});
	}

	

	
	

	@Table(name = "User")
	@Entity
	@Data
	static class User extends com.knits.jpa.orm.entities.common.User implements Serializable {

		// @Review (5): cascade policy = propagate action to child entity
		@OneToOne(mappedBy = "user", cascade = CascadeType.PERSIST)
		//@OneToOne(mappedBy = "user")
		@PrimaryKeyJoinColumn
		private Address address;

		
		// @Review (2):Better to handle bidirectional association in parent class
		public void setAddress(Address address) {

			if (address != null) {
				address.setUser(this);
			} else if (this.address != null) {
				this.address.setUser(null); // remove both side of association in case of address=null
			}

			this.address = address;
		}
	}

	@Table(name = "Address")
	@Entity
	@Data
	static class Address extends com.knits.jpa.orm.entities.common.Address implements Serializable {

		@Id
		private Long id;
		
		@OneToOne
		@MapsId
		@JoinColumn(name = "id")
		private User user;

	}


	
	private Address address;
	private User user;
	

	@Override
	protected Class<?>[] entities() {
		return new Class[] { Address.class, User.class };
	}

	@Before
	public void init() {
		super.init();
		address = new Address();
		user = new User();
		MockEntities.fillData(address);
		MockEntities.fillData(user);
	}

	@After
	public void cleanup() {
		doInJPATransaction(entityManager -> {
			log.info("Remove last persisted entities");

			// @Review (1): If entity was persisted has id. In that case load it from DB and
			// delete it.

			if (user.getId() != null) {
				User userInDB = entityManager.find(User.class, user.getId());
				if (userInDB != null) {
					entityManager.remove(userInDB);
				}
			}

			if (address.getUser()!=null &&  address.getUser().getId() != null) {
				Address addressInDb = entityManager.find(Address.class, address.getUser().getId());
				if (addressInDb != null) {
					entityManager.remove(addressInDb);
				}
			}
		});
	}


}
